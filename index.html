<html lang="nl"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¢ Coaster Tinder üé¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4CA1AF 0%, #2C3E50 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4CA1AF 0%, #2C3E50 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        /* Header layout helpers */
        .header-inner {
            position: relative;
            max-width: 1100px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: nowrap;
        }

        .header-left, .header-right {
            position: absolute;
            top: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-left { left: 16px; }
        .header-right { right: 16px; }

        .header-center { display: flex; flex-direction: column; align-items: center; }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .keyboard-hint {
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.9;
            text-align: center;
        }
        /* make the entire battle tab the positioning context so the hint sits at the bottom of the tab */
        #battle-tab { position: relative; }
        .keyboard-hint {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            padding: 6px 30px 6px 10px;
            background: rgba(255,255,255,0.9);
            color: #333;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: auto;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .keyboard-hint.hidden {
            display: none;
        }

        .keyboard-hint-close {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: #666;
            font-size: 1.2em;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            line-height: 1;
            transition: all 0.2s;
        }

        .keyboard-hint-close:hover {
            background: rgba(0,0,0,0.1);
            color: #333;
        }

        .user-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        /* Hamburger user menu */
        .hamburger-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 700;
        }

        .user-menu {
            position: absolute;
            right: 0;
            top: 40px;
            background: white;
            color: #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 2000;
            min-width: 160px;
        }

        .user-menu.open { display: flex; }

        .user-menu .user-btn {
            padding: 10px 12px;
            border: none;
            background: transparent;
            color: #333;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            text-align: left;
        }

        .user-menu .user-btn:hover { background: #f1f1f1; }

        .user-menu .user-btn.active { background: #4CA1AF; color: white; }

        /* Responsive: stack badge and hamburger on narrow viewports */
        @media (max-width: 600px) {
            .header {
                text-align: left;
                padding-right: 16px;
                padding-left: 16px;
            }

            .header-inner {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .header-center { align-items: flex-start; }
            .header h1, .header p, .keyboard-hint { text-align: left; }

            .current-user-badge, .hamburger-btn {
                position: static;
                margin: 6px 0;
                left: auto;
                top: auto;
            }

            .user-menu {
                position: static;
                box-shadow: 0 6px 18px rgba(0,0,0,0.12);
                margin-top: 6px;
                right: auto;
                top: auto;
                min-width: 140px;
            }
            .keyboard-hint { display: none; }
        }

        .user-btn {
            padding: 12px 30px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .user-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .user-btn.active {
            background: white;
            color: #4CA1AF;
        }

        .current-user-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 0.95em;
            z-index: 2010;
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s;
            border: none;
            background: none;
        }

        .tab:hover {
            background: #e0e0e0;
        }

        .tab.active {
            background: white;
            color: #4CA1AF;
            border-bottom: 3px solid #4CA1AF;
        }

        .tab-content {
            display: none;
            padding: 40px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block;
        }

        /* Battle Tab */
        .battle-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: stretch;
            flex-wrap: wrap;
        }

        .coaster-card {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            background: linear-gradient(135deg, #f5f7fa 0%, #91c0c4 100%);
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        .left-card {
            text-align: right;
        }

        .coaster-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
        }

        .coaster-card.winner {
            animation: winShine 1.5s ease-out, winBounce 1.5s ease-out;
            box-shadow: 0 20px 40px rgba(16, 185, 129, 0.4);
        }

        .coaster-card.loser {
            transform: scale(0.92);
            opacity: 0.7;
            transition: all 0.4s ease;
            animation: loserRecover 0.3s ease 1.3s forwards;
        }

        @keyframes loserRecover {
            to {
            transform: scale(1);
            opacity: 1;
            }
        }

        @keyframes winShine {
            0% {
                box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            }
            20% {
                box-shadow: 0 0 30px 10px rgba(212, 255, 132, 0.8),
                            0 0 50px 20px rgba(255, 215, 0, 0.4),
                            0 20px 40px rgba(16, 185, 129, 0.4);
            }
            40% {
                box-shadow: 0 0 20px 5px rgba(162, 255, 0, 0.6),
                            0 20px 40px rgba(16, 185, 129, 0.4);
            }
            100% {
                box-shadow: 0 20px 40px rgba(16, 185, 129, 0.4);
            }
        }

        @keyframes winBounce {
            0%, 100% {
                transform: translateY(0);
            }
            10% {
                transform: translateY(-15px);
            }
            20% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
            40% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
            60% {
                transform: translateY(0);
            }
        }

        /*
        
        .coaster-card.left-card::before {
            content: '‚Üê Linker pijltje';
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #4CA1AF;
            font-weight: 600;
            text-align: right;
        }
        
       

        .coaster-card.right-card::before {
            content: 'Rechter pijltje ‚Üí';
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(118, 75, 162, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #2C3E50;
            font-weight: 600;
            text-align: left;
        }

         */

        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Rank climb animation */
        .rank-change-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: badgePopIn 0.4s ease-out, badgeFadeOut 0.5s ease-in 3.5s forwards;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            z-index: 10;
        }

        .rank-change-badge .arrow {
            font-size: 1.3em;
            animation: arrowBounce 0.6s ease-in-out infinite;
        }

        .rank-change-badge .confetti {
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 1.2em;
            animation: confettiPop 0.6s ease-out;
        }

        @keyframes badgePopIn {
            0% { 
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            60% {
                transform: scale(1.2) rotate(10deg);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes badgeFadeOut {
            to { 
                opacity: 0;
                transform: translateY(-20px) scale(0.8);
            }
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes confettiPop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(360deg) translateY(-30px);
                opacity: 0;
            }
        }

        .coaster-name {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .coaster-info {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .coaster-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .coaster-info-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .info-label {
            font-weight: 600;
            color: #666;
        }

        .info-value {
            color: #333;
            text-align: right;
        }

        .choose-btn {
            background: linear-gradient(135deg, #4CA1AF 0%, #2C3E50 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .choose-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .vs-divider {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: #4CA1AF;
            min-width: 50px;
            padding: 15px;
        }

        /* Ranking Tab */
        .ranking-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stats-summary {
            background: #f5f7fa;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CA1AF;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
        }

        .reset-panel {
            margin-top: 24px;
            padding: 18px 20px;
            background: #f7fafc;
            border: 1px solid #e3e8ee;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.06);
            flex-wrap: wrap;
        }

        .reset-panel .reset-copy {
            color: #445;
            font-weight: 600;
            font-size: 0.98em;
        }

        .reset-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #f03e3e 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 10px 25px rgba(240, 62, 62, 0.25);
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 28px rgba(240, 62, 62, 0.32);
        }

        .reset-btn:active {
            transform: translateY(0);
            box-shadow: 0 6px 14px rgba(240, 62, 62, 0.2);
        }

        .ranking-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .ranking-table th {
            background: linear-gradient(135deg, #4CA1AF 0%, #2C3E50 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }

        .ranking-table th:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8b 100%);
        }

        .ranking-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }

        .ranking-table tr:hover {
            background: #f5f7fa;
        }

        .rank-medal {
            font-size: 1.2em;
            margin-right: 5px;
        }

        .elo-score {
            font-weight: bold;
            color: #4CA1AF;
            font-size: 1.1em;
        }

        .clickable-stat {
            cursor: pointer;
            color: #4CA1AF;
            font-weight: 600;
            transition: all 0.2s;
        }

        .clickable-stat:hover {
            color: #2C3E50;
            text-decoration: underline;
        }

        .autocomplete-container {
            position: relative;
            display: inline-block;
            max-width: 360px;
            width: 100%;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid #f0f0f0;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background: #f5f7fa;
        }

        .autocomplete-item.selected {
            background: #e8f4f8;
        }

        .no-battles {
            text-align: center;
            padding: 60px;
            color: #999;
            font-size: 1.2em;
        }

        /* Mobile card view for ranking */
        .ranking-cards {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            background: transparent;
        }

        .ranking-card {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .ranking-left { display: flex; flex-direction: column; gap: 6px; }
        .ranking-right { text-align: right; }
        .ranking-card .rank { font-weight: 800; color: #333; font-size: 1.1em; }
        .ranking-card .name { font-weight: 700; font-size: 1em; }
        .ranking-card .meta { color: #888; font-size: 0.85em; }
        .ranking-card .elo { color: #4CA1AF; font-weight: 800; font-size: 1.05em; }
        .ranking-card .stats { display: flex; gap: 10px; justify-content: flex-end; margin-top: 6px; }

        @media (max-width: 820px) {
            .ranking-table { display: none; }
            .ranking-cards { display: flex; }
        }

        /* History styles */
        .history-row {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            gap: 8px;
            align-items: center;
        }

        .winner-pill {
            display: inline-block;
            background: #e6fbec;
            color: #0b6f35;
            padding: 6px 10px;
            border-radius: 12px;
            font-weight: 700;
        }

        .history-delete {
            background: transparent;
            border: none;
            color: #888;
            font-size: 1.05em;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
        }

        .history-delete:hover {
            color: #d00;
            background: rgba(0,0,0,0.03);
        }

        .history-switch {
            background: transparent;
            border: none;
            color: #4CA1AF;
            font-size: 1.05em;
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            margin-right: 4px;
        }

        .history-switch:hover {
            color: #2C3E50;
            background: rgba(76, 161, 175, 0.1);
        }

        .history-pair {
            text-align: center;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%) translateY(6px);
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 10px 14px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            font-weight: 600;
            opacity: 0;
            transition: opacity 220ms ease, transform 220ms ease;
            z-index: 9999;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .search-box {
            padding: 12px 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            width: 100%;
            max-width: 400px;
            transition: border 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: #4CA1AF;
        }

        .search-input-wrapper {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
        }

        .clear-search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: #999;
            font-size: 1.2em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            line-height: 1;
            transition: all 0.2s;
        }

        .clear-search-btn:hover {
            color: #333;
            background: rgba(0,0,0,0.05);
        }

        .pairing-help {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            max-width: 760px;
            margin: 6px auto 14px auto;
            line-height: 1.4;
        }

        /* Segmented pairing toggle */
        .pair-toggle { background: #fff; }
        .pair-toggle .pair-option {
            padding: 8px 14px;
            border: none;
            background: white;
            cursor: pointer;
            font-weight: 600;
            color: #333;
            position: relative;
            min-width: 110px;
        }
        .pair-toggle .pair-option + .pair-option { border-left: 1px solid #eee; }
        .pair-toggle .pair-option.active {
            background: linear-gradient(135deg, #4CA1AF 0%, #2C3E50 100%);
            color: #fff;
        }
        .pair-option .help-pop {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.85em;
            z-index: 999;
            box-shadow: 0 6px 20px rgba(0,0,0,0.18);
        }
        .pair-option:hover .help-pop { display: block; }

        /* Floating tooltip that follows cursor (used for pair-option help) */
        .floating-help {
            position: fixed;
            pointer-events: none;
            background: rgba(0,0,0,0.80);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.9em;
            opacity: 0;
            transform: translate(-50%, 8px);
            transition: opacity 180ms ease, transform 180ms ease;
            z-index: 10000;
            white-space: nowrap;
        }
        .floating-help.show { opacity: 1; transform: translate(-50%, 0); }

        .pairing-controls-wrapper { display:flex;flex-direction:column;align-items:center; }
        #pairingControls { max-height: 240px; opacity: 1; }
        #pairingControls.collapsed { max-height: 0; opacity: 0; padding: 0; margin: 0; pointer-events: none; }
        .pairing-toggle-btn { transition: transform 180ms ease, background 120ms ease; }
        .pairing-toggle-btn.collapsed { transform: rotate(180deg); }

        .filter-container {
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .battle-container {
                flex-direction: column;
            }

            .vs-divider {
                /* transform: rotate(90deg); */
                margin: 20px 0;
            }

            .coaster-card {
                max-width: 100%;
            }

            .user-selector {
                flex-direction: column;
            }

            .left-card {
                text-align: left;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-inner">
                <div class="header-left">
                    <div class="current-user-badge" id="currentUserBadge">Selecteer een gebruiker</div>
                </div>

                <div class="header-center">
                    <h1>Coaster Ranker</h1>
                    <p>Ontdek jouw favoriete achtbaan</p>
                </div>

                <div class="header-right">
                    <button id="userMenuToggle" class="hamburger-btn" aria-haspopup="true" aria-expanded="false" title="Gebruiker kiezen" onclick="toggleUserMenu()">‚ò∞</button>
                    <div id="userMenu" class="user-menu" aria-hidden="true">
                        <button class="user-btn" onclick="switchUser('luca')" id="btn-luca">üë§ Luca</button>
                        <button class="user-btn" onclick="switchUser('wouter')" id="btn-wouter">üë§ Wouter</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('battle')">Battle</button>
            <button class="tab" onclick="switchTab('ranking')">Ranking</button>
            <button class="tab" onclick="switchTab('history')">History</button>
        </div>

        <div id="battle-tab" class="tab-content active">
            <div class="vs-divider">VS</div>
            <div class="battle-area">
                <div class="battle-container" id="battleContainer">
                    <div class="no-battles">Selecteer eerst een gebruiker hierboven! üëÜ</div>
                </div>
                <p class="keyboard-hint" id="keyboardHint">
                    ‚å®Ô∏è Tip: Gebruik de pijltjestoetsen! ‚Üê Links | Rechts ‚Üí
                    <button class="keyboard-hint-close" onclick="closeKeyboardHint()" title="Sluiten">‚úï</button>
                </p>
            </div>
            <div class="pairing-controls-wrapper" style="margin:12px 0;">
                <div style="display:flex;justify-content:center;align-items:center;">
                    <div style="font-size:0.95em;color:#444;display:flex;align-items:center;gap:8px;"></div>
                    <button id="pairingControlsToggle" class="pairing-toggle-btn" onclick="togglePairingControls()" aria-expanded="true" title="Verberg instellingen" style="margin-left:8px;padding:6px 8px;border-radius:8px;border:none;background:#fff;cursor:pointer;font-weight:700;">‚ñæ</button>
                </div>

                <div id="pairingControls" class="pairing-controls" style="display:flex;flex-direction:column;align-items:center;gap:8px;margin-top:8px;transition:max-height 260ms ease,opacity 180ms ease;overflow:hidden;">
                    <div class="pair-toggle" style="display:flex;border:1px solid #ddd;border-radius:10px;overflow:hidden;">
                        <button class="pair-option" data-value="hybrid" data-help="kiest eerst een onderbemonsterde achtbaan, daarna een tegenstander met vergelijkbare ELO (balanceert verkenning en verfijning)" onclick="setPairingStrategy('hybrid')">
                            Hybrid
                        </button>
                        <button class="pair-option" data-value="exploration" data-help="beide keuzes geven prioriteit aan onderbemonsterde achtbanen (sneller coverage)" onclick="setPairingStrategy('exploration')">
                            Exploration
                        </button>
                        <button class="pair-option" data-value="uniform" data-help="volledig willekeurig (geen bias)" onclick="setPairingStrategy('uniform')">
                            Uniform
                        </button>
                    </div>

                    <div style="display:flex;align-items:center;gap:8px;font-size:0.95em;color:#444;">
                        ELO-proximity:
                        <input id="eloProximityRange" type="range" min="0" max="4" step="0.1" value="1" oninput="setEloProximityPower(this.value)" style="width:180px;">
                        <span id="eloProximityValue" style="min-width:36px;text-align:center;font-weight:700;color:#2c3e50;">1.0</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="history-tab" class="tab-content">
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:16px; gap:10px;">
                <div class="autocomplete-container">
                    <div class="search-input-wrapper">
                        <input id="historySearch" type="text" class="search-box" placeholder="üîç Zoek matchup..." oninput="handleHistorySearchInput()" onkeydown="handleHistorySearchKeydown(event)" onfocus="showHistoryAutocomplete()" style="width:100%;" />
                        <button id="clearHistorySearchBtn" class="clear-search-btn" onclick="clearHistorySearch()" style="display:none;" title="Clear search">‚úï</button>
                    </div>
                    <div id="historyAutocomplete" class="autocomplete-dropdown"></div>
                </div>
            </div>
            <div id="historyContainer" style="overflow:auto; max-height:420px;">
                <div class="no-battles">Nog geen battles ‚Äî start met kiezen om history op te bouwen.</div>
            </div>
        </div>

        <div id="ranking-tab" class="tab-content">
            <div class="ranking-controls">
                <div class="stats-summary">
                    <div class="stat-item">
                        <div class="stat-value" id="totalBattles">0</div>
                        <div class="stat-label">Totaal Battles</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalCoasters">0</div>
                        <div class="stat-label">Achtbanen</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgBattlesPerCoaster">0</div>
                        <div class="stat-label">Gem. Battles/Achtbaan</div>
                    </div>
                </div>
            </div>

            <div class="filter-container">
                <input type="text" class="search-box" id="searchBox" placeholder="üîç Zoek achtbaan, park of fabrikant..." onkeyup="filterRanking()">
            </div>

            <table class="ranking-table" id="rankingTable">
                <thead>
                    <tr>
                        <th onclick="sortRanking('rank')">Rank</th>
                        <th onclick="sortRanking('name')">Naam</th>
                        <th onclick="sortRanking('park')">Park</th>
                        <th onclick="sortRanking('manufacturer')">Fabrikant</th>
                        <th onclick="sortRanking('elo')">ELO ‚¨áÔ∏è</th>
                        <th onclick="sortRanking('battles')">Battles</th>
                        <th onclick="sortRanking('wins')">Wins</th>
                        <th onclick="sortRanking('losses')">Losses</th>
                        <th onclick="sortRanking('winrate')">Win %</th>
                    </tr>
                </thead>
                <tbody id="rankingBody">
                    <tr><td colspan="9" class="no-battles">Selecteer eerst een gebruiker! üé¢</td></tr>
                </tbody>
            </table>

            <div class="reset-panel">
                <div class="reset-copy">Reset alle rankings, battles en geschiedenis voor de huidige gebruiker.</div>
                <button class="reset-btn" onclick="resetRankings()">üîÑ Reset Alles</button>
            </div>
        </div>
    </div>

    <script>
        // Luca's coaster data
        const coastersDataLuca = [
            {"naam":"Der Schwur des K√§rnan","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Troy","park":"Toverland","fabrikant":"GCI","operatief":1},
            {"naam":"Ride to Happiness","park":"Plopsaland DePanne","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Taron","park":"Phantasialand","fabrikant":"Intamin","operatief":1},
            {"naam":"Hyperion","park":"Energylandia","fabrikant":"Intamin","operatief":1},
            {"naam":"Voltron","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Shambhala","park":"PortAventura","fabrikant":"B&M","operatief":1},
            {"naam":"Colossos - Kampf der Giganten","park":"Heide Park","fabrikant":"Intamin","operatief":1},
            {"naam":"Zadra","park":"Energylandia","fabrikant":"RMC","operatief":1},
            {"naam":"Red Force","park":"Ferrari Land","fabrikant":"Intamin","operatief":1},
            {"naam":"Kondaa","park":"Walibi Belgium","fabrikant":"Intamin","operatief":1},
            {"naam":"Flucht von Novgorod","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Untamed","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Rutschebanen","park":"Tivoli Gardens","fabrikant":"Valdemar Lebech","operatief":1},
            {"naam":"F.L.Y.","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Baron 1898","park":"Efteling","fabrikant":"B&M","operatief":1},
            {"naam":"Vertigo","park":"Walibi Belgium","fabrikant":"Doppelmayr","operatief":0},
            {"naam":"Black  Mamba","park":"Phantasialand","fabrikant":"B&M","operatief":1},
            {"naam":"Abyssus","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Karacho","park":"Tripsdrill","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Cancan Coaster","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Flug der D√§monen","park":"Heide Park","fabrikant":"B&M","operatief":1},
            {"naam":"Fenix","park":"Toverland","fabrikant":"B&M","operatief":1},
            {"naam":"Wodan Timber Coaster","park":"Europa Park","fabrikant":"GCI","operatief":1},
            {"naam":"Expedition GeForce","park":"Holiday Park","fabrikant":"Intamin","operatief":1},
            {"naam":"Van Helsing's Factory","park":"Moviepark Germany","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Dragon Khan","park":"PortAventura","fabrikant":"B&M","operatief":1},
            {"naam":"Anubis the Ride","park":"Plopsaland DePanne","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Turbine","park":"Walibi Belgium","fabrikant":"Schwarzkopf","operatief":0},
            {"naam":"Blue Fire","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Silver Star","park":"Europa Park","fabrikant":"B&M","operatief":1},
            {"naam":"Hals-√ºber-Kopf","park":"Tripsdrill","fabrikant":"Vekoma","operatief":1},
            {"naam":"Heidi the Ride","park":"Plopsaland DePanne","fabrikant":"GCI","operatief":1},
            {"naam":"Gold Rush","park":"Slagharen","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Cop Car Chase","park":"Moviepark Germany","fabrikant":"Intamin","operatief":0},
            {"naam":"Olympia Looping","park":"Prater Park","fabrikant":"Schwarzkopf","operatief":1},
            {"naam":"ARTHUR","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Furius Baco","park":"PortAventura","fabrikant":"Intamin","operatief":1},
            {"naam":"Nessie","park":"Hansa Park","fabrikant":"Schwarzkopf","operatief":1},
            {"naam":"Goliath","park":"Walibi Holland","fabrikant":"Intamin","operatief":1},
            {"naam":"De Vliegende Hollander","park":"Efteling","fabrikant":"KumbaK","operatief":1},
            {"naam":"Krake","park":"Heide Park","fabrikant":"B&M","operatief":1},
            {"naam":"Booster Bike","park":"Toverland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Dwervelwind","park":"Toverland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Speed","park":"Energylandia","fabrikant":"Intamin","operatief":1},
            {"naam":"Lost Gravity","park":"Walibi Holland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"G'sengte Sau","park":"Tripsdrill","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Joris en de draak - Water","park":"Efteling","fabrikant":"GCI","operatief":1},
            {"naam":"Joris en de draak - Vuur","park":"Efteling","fabrikant":"GCI","operatief":1},
            {"naam":"Euro-Mir","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Uncharted","park":"PortAventura","fabrikant":"Intamin","operatief":1},
            {"naam":"Fury","park":"Bobbejaanland","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Swiss Bob Run","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Tiki Waka","park":"Walibi Belgium","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Speedy Bob","park":"Bobbejaanland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Eurosat","park":"Europa Park","fabrikant":"Mack Rides","operatief":0},
            {"naam":"Matterhorn Blitz","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Atlantica SuperSplash","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Colorado Adventure","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Calamity Mine","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Pegasus","park":"Efteling","fabrikant":"Intamin","operatief":0},
            {"naam":"YOY Thrill","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Poseidon","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Dragon Rollercoaster","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Sky Scream","park":"Holiday Park","fabrikant":"Premier Rides","operatief":1},
            {"naam":"Schlange von Midgard","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"The Milky Way Express","park":"Tivoli Gardens","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Typhoon","park":"Bobbejaanland","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Python","park":"Efteling","fabrikant":"Vekoma","operatief":1},
            {"naam":"YOY Chill","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Big Loop","park":"Heide Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"Vampire","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Loup Garou","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Stampedia","park":"PortAventura","fabrikant":"CCI","operatief":1},
            {"naam":"Vogelrok","park":"Efteling","fabrikant":"Vekoma","operatief":1},
            {"naam":"Dreamcatcher","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Revolution","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Winja's - Fear","park":"Phantasialand","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Winja's - Force","park":"Phantasialand","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Toos-Express","park":"Toverland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Xpress: Platform 13","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"De Bob","park":"Efteling","fabrikant":"Intamin","operatief":0},
            {"naam":"Speed of Sound","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Max","park":"Efteling","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Robin Hood","park":"Walibi Holland","fabrikant":"Vekoma","operatief":0},
            {"naam":"Formula","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"D√¶monen","park":"Tivoli Gardens","fabrikant":"B&M","operatief":1},
            {"naam":"Alpenexpress Enzian","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Mammut","park":"Tripsdrill","fabrikant":"Zierer","operatief":1},
            {"naam":"Temple of the Night Hawk","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Raik","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Volldampf","park":"Tripsdrill","fabrikant":"Vekoma","operatief":1},
            {"naam":"Boomerang","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Cobra","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Bobbahn","park":"Heide Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Spyk√© Underground","park":"Walibi Belgium","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Diablo - Tren de la Mina","park":"PortAventura","fabrikant":"Arrow","operatief":1},
            {"naam":"Mayan","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Condor","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Limit","park":"Heide Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"MP-Xpress","park":"Moviepark Germany","fabrikant":"Vekoma","operatief":1},
            {"naam":"Tomahawk","park":"PortAventura","fabrikant":"CCI","operatief":1},
            {"naam":"Rioolrat","park":"Hellendoorn","fabrikant":"Vekoma","operatief":1},
            {"naam":"Naga Bay","park":"Bobbejaanland","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Bandit","park":"Moviepark Germany","fabrikant":"RCCA","operatief":1},
            {"naam":"Light Explores","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Crazy Mine","park":"Hansa Park","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Gohst Chasers","park":"Moviepark Germany","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Mine Train","park":"Slagharen","fabrikant":"Vekoma","operatief":1},
            {"naam":"Jul's RollerSkates","park":"Juliana Toren","fabrikant":"Vekoma","operatief":1},
            {"naam":"Royal Scotsman","park":"Hansa Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"Donderstenen","park":"Hellendoorn","fabrikant":"Zierer","operatief":1},
            {"naam":"Grottenblitz","park":"Heide Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Indy-Blitz","park":"Heide Park","fabrikant":"Zierer","operatief":1},
            {"naam":"Familieachtbaan","park":"BillyBird Park Hemelrijk","fabrikant":"ABC Rides","operatief":1},
            {"naam":"Rasender Tausendf√º√üler","park":"Tripsdrill","fabrikant":"Zierer","operatief":1},
            {"naam":"Fun Pilot","park":"Walibi Belgium","fabrikant":"Zamperla","operatief":1},
            {"naam":"Tami-Tami","park":"PortAventura","fabrikant":"Vekoma","operatief":1},
            {"naam":"Ba-a-a Express","park":"Europa Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Fryda","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Drako","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Achterbahn","park":"Wunderland Kalkar","fabrikant":"Zamperla","operatief":1},
            {"naam":"Junior Red Force","park":"Ferrari Land","fabrikant":"SBF Visa","operatief":1},
            {"naam":"Energus","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Draak","park":"Plopsaland DePanne","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Bob Express","park":"Bobbejaanland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Oki Doki","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Kleine Zar","park":"Hansa Park","fabrikant":"Preston & Bareiri","operatief":1},
            {"naam":"Volare","park":"Prater Park","fabrikant":"Zamperla","operatief":1},
            {"naam":"Viking Rollercoaster","park":"Energylandia","fabrikant":"SBF Visa","operatief":1}
        ];

        // Wouter's coaster data
        const coastersDataWouter = [
            {"naam":"Der Schwur des K√§rnan","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Hyperion","park":"Energylandia","fabrikant":"Intamin","operatief":1},
            {"naam":"Zadra","park":"Energylandia","fabrikant":"RMC","operatief":1},
            {"naam":"Ride to Happiness","park":"Plopsaland de Panne","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Untamed","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Taron","park":"Phantasialand","fabrikant":"Intamin","operatief":1},
            {"naam":"Voltron","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Shambhala","park":"PortAventura","fabrikant":"B&M","operatief":1},
            {"naam":"Batman Gotham City Escape","park":"Parque Warner","fabrikant":"Intamin","operatief":1},
            {"naam":"Kondaa","park":"Walibi Belgium","fabrikant":"Intamin","operatief":1},
            {"naam":"Red Force","park":"Ferrari Land","fabrikant":"Intamin","operatief":1},
            {"naam":"Troy","park":"Toverland","fabrikant":"GCI","operatief":1},
            {"naam":"Flucht von Novgorod","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"F.L.Y.","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Fenix","park":"Toverland","fabrikant":"B&M","operatief":1},
            {"naam":"Superman / la Atracci√≥n de Acero","park":"Parque Warner","fabrikant":"B&M","operatief":1},
            {"naam":"Abyssus","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Furius Baco","park":"PortAventura","fabrikant":"Intamin","operatief":1},
            {"naam":"Colossos - Kampf der Giganten","park":"Heide Park","fabrikant":"Intamin","operatief":1},
            {"naam":"Flug der D√§monen","park":"Heide Park","fabrikant":"B&M","operatief":1},
            {"naam":"Dragon Khan","park":"PortAventura","fabrikant":"B&M","operatief":1},
            {"naam":"Wodan Timbur Coaster","park":"Europa-Park","fabrikant":"GCI","operatief":1},
            {"naam":"Black  Mamba","park":"Phantasialand","fabrikant":"B&M","operatief":1},
            {"naam":"Karacho","park":"Tripsdrill","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Anubis The Ride","park":"Plopsaland de Panne","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Hals-√ºber-Kopf","park":"Tripsdrill","fabrikant":"Vekoma","operatief":1},
            {"naam":"Goliath","park":"Walibi Holland","fabrikant":"Intamin","operatief":1},
            {"naam":"Blue fire Megacoaster","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Baron 1898","park":"Efteling","fabrikant":"B&M","operatief":1},
            {"naam":"Lost Gravity","park":"Walibi Holland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Abismo","park":"Parque de attractiones","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Shadow of Arkham","park":"Parque Warner","fabrikant":"B&M","operatief":1},
            {"naam":"Van Helsing's Factory","park":"Moviepark Germany","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Gold Rush","park":"Slagharen","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Fury","park":"Bobbejaanland","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"De Vliegende Hollander","park":"Efteling","fabrikant":"KumbaK","operatief":1},
            {"naam":"Olympia Looping","park":"Prater Park","fabrikant":"Schwarzkopf","operatief":1},
            {"naam":"Joris en de draak - Water","park":"Efteling","fabrikant":"GCI","operatief":1},
            {"naam":"Joris en de draak - Vuur","park":"Efteling","fabrikant":"GCI","operatief":1},
            {"naam":"Formula","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Eurosat - CanCan Coaster","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"YOY Thrill","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Silver Star","park":"Europa-Park","fabrikant":"B&M","operatief":1},
            {"naam":"Stuntfall","park":"Parque Warner","fabrikant":"Vekoma","operatief":1},
            {"naam":"Revolution","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"YOY Chill","park":"Walibi Holland","fabrikant":"RMC","operatief":1},
            {"naam":"Nessie","park":"Hansa Park","fabrikant":"Schwarzkopf","operatief":1},
            {"naam":"Uncharted","park":"PortAventura","fabrikant":"Intamin","operatief":1},
            {"naam":"Speed","park":"Energylandia","fabrikant":"Intamin","operatief":1},
            {"naam":"Tarantula","park":"Parque de attractiones","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Heide The Ride","park":"Plopsaland de Panne","fabrikant":"GCI","operatief":1},
            {"naam":"Xpress: Platform 13","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Arthur","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Dwervelwind","park":"Toverland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Colorado Adventure","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Winja's - Fear","park":"Phantasialand","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Winja's - Force","park":"Phantasialand","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Dragon Roller Coaster","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"De Bob","park":"Efteling","fabrikant":"Intamin","operatief":0},
            {"naam":"G'sengte Sau","park":"Tripsdrill","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Pulsar","park":"Walibi Belgium","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Stampedia","park":"PortAventura","fabrikant":"CCI","operatief":1},
            {"naam":"Krake","park":"Heide Park","fabrikant":"B&M","operatief":1},
            {"naam":"Tiki-Waka","park":"Walibi Belgium","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Correcaminos Bip, Bip","park":"Parque Warner","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Tornado","park":"Parque de attractiones","fabrikant":"Intamin","operatief":1},
            {"naam":"Robin Hood","park":"Walibi Holland","fabrikant":"Vekoma","operatief":0},
            {"naam":"Falcon","park":"Duinrell","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Typhoon","park":"Bobbejaanland","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Euro Mir","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Speed of Sound","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Diablo - Tren de la Mina","park":"PortAventura","fabrikant":"Arrow","operatief":1},
            {"naam":"Crazy Bats (VR)","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Cobra","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Balagos (Tornado)","park":"Hellendoorn","fabrikant":"Vekoma","operatief":1},
            {"naam":"Thunder Loop","park":"Slagharen","fabrikant":"Schwarzkopf","operatief":0},
            {"naam":"Bobbahn","park":"Heide Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Calamity Mine","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Poseidon","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Max & Moritz","park":"Efteling","fabrikant":"Mack Rides","operatief":1},
            {"naam":"TNT Tren de la Mina","park":"Parque de attractiones","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Naga bay","park":"Bobbejaanland","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Tomahawk","park":"PortAventura","fabrikant":"CCI","operatief":1},
            {"naam":"Raik","park":"Phantasialand","fabrikant":"Vekoma","operatief":1},
            {"naam":"Volldampf","park":"Tripsdrill","fabrikant":"Vekoma","operatief":1},
            {"naam":"Boomerang","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Light Explorers","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Vogelrok","park":"Efteling","fabrikant":"Vekoma","operatief":1},
            {"naam":"Vampire","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Condor","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Roller Coaster Mayan","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Limit","park":"Heide Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"Dream catcher","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Jimmy Neutron's Atomic Flyer","park":"Moviepark Germany","fabrikant":"Vekoma","operatief":1},
            {"naam":"MP Xpress","park":"Moviepark Germany","fabrikant":"Vekoma","operatief":1},
            {"naam":"Python","park":"Efteling","fabrikant":"Vekoma","operatief":1},
            {"naam":"Big Loop","park":"Heide Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"Booster Bike","park":"Toverland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Rioolrat","park":"Hellendoorn","fabrikant":"Vekoma","operatief":1},
            {"naam":"Pegasus","park":"Efteling","fabrikant":"Intamin","operatief":0},
            {"naam":"Coaster Express","park":"Parque Warner","fabrikant":"RCCA","operatief":1},
            {"naam":"Psych√© Underground","park":"Walibi Belgium","fabrikant":"Schwarzkopf","operatief":1},
            {"naam":"Royal Scotsman","park":"Hansa Park","fabrikant":"Vekoma","operatief":1},
            {"naam":"Mammut","park":"Tripsdrill","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Flying Dutchman Gold Mine","park":"Walibi Holland","fabrikant":"Vekoma","operatief":0},
            {"naam":"Crazy Mine","park":"Hansa Park","fabrikant":"Mauer Rides","operatief":1},
            {"naam":"Speedy bob","park":"Bobbejaanland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Vertigo","park":"Parque de attractiones","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Ghost Chasers","park":"Moviepark Germany","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Matterhorn Blitz","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Atlantica SuperSplash","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Loup Garou","park":"Walibi Belgium","fabrikant":"Vekoma","operatief":1},
            {"naam":"Bandit","park":"Moviepark Germany","fabrikant":"RCCA","operatief":1},
            {"naam":"Schweizer Bobbahn","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Schlange von Midgard","park":"Hansa Park","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Mine Train","park":"Slagharen","fabrikant":"Vekoma","operatief":1},
            {"naam":"Frida","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Tom y Jerry","park":"Parque Warner","fabrikant":"Zierer","operatief":1},
            {"naam":"Pegasus","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Kikkerachtbaan","park":"Duinrell","fabrikant":"Zierer","operatief":1},
            {"naam":"Rasender Tausendf√º√üler","park":"Tripsdrill","fabrikant":"Zierer","operatief":1},
            {"naam":"Energus","park":"Energylandia","fabrikant":"Vekoma","operatief":1},
            {"naam":"Dragon Fly","park":"Duinrell","fabrikant":"Gerstlauer","operatief":1},
            {"naam":"Jul's RollerSkates","park":"Juliana Toren","fabrikant":"Vekoma","operatief":1},
            {"naam":"Donderstenen","park":"Hellendoorn","fabrikant":"Zierer","operatief":1},
            {"naam":"Oki doki","park":"Bobbejaanland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Fun Pilot","park":"Walibi Belgium","fabrikant":"Zamperla","operatief":1},
            {"naam":"Tami-Tami","park":"PortAventura","fabrikant":"Vekoma","operatief":1},
            {"naam":"Toos-Express","park":"Toverland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Backyardigans: Misson to Mars","park":"Moviepark Germany","fabrikant":"Vekoma","operatief":1},
            {"naam":"Grottenblitz","park":"Heide Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Indy-Blitz","park":"Heide Park","fabrikant":"Zierer","operatief":1},
            {"naam":"Draak","park":"Plopsaland de Panne","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Drako","park":"Walibi Holland","fabrikant":"Vekoma","operatief":1},
            {"naam":"Kleine Zar","park":"Hansa Park","fabrikant":"Preston & Bareiri","operatief":1},
            {"naam":"Bob express","park":"Bobbejaanland","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Ba-a-a-Express","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Junior Red Force","park":"Ferrari Land","fabrikant":"SBF Visa","operatief":1},
            {"naam":"Achterbahn","park":"Wunderland Kalkar","fabrikant":"Zamperla","operatief":1},
            {"naam":"Alpenexpress Enzian","park":"Europa-Park","fabrikant":"Mack Rides","operatief":1},
            {"naam":"Volare","park":"Prater Park","fabrikant":"Zamperla","operatief":1},
            {"naam":"Viking Roller Coaster","park":"Energylandia","fabrikant":"SBF Visa","operatief":1}
        ];

        // Global variables
        let currentUser = null;
        let coasters = [];
        let coasterStats = {};
        let totalBattlesCount = 0;
        let currentBattle = null;
        let isProcessingChoice = false;
        let currentSort = { column: 'elo', ascending: false };
        // History: stores past battles for current user
        let coasterHistory = [];
        // Stack for undoing deletions (LIFO)
        let deletedHistoryStack = [];
        const MAX_UNDO_STACK = 50;
        // Exploration boost: favor coasters with few battles
        const EXPLORATION_POWER = 1; // higher => stronger preference for low-battles
        // ELO-proximity: prefer opponents whose ELO is similar (more informative matches)
        let ELO_PROXIMITY_POWER = 1; // higher => stronger preference for similar ELO
        const ELO_DIFF_SCALE = 400; // scale (in ELO points) used to normalize differences
        // Pairing strategy: 'hybrid' recommended ‚Äî picks one under-sampled coaster
        // then picks a second that is ELO-similar while still favoring under-sampled ones.
        // Other options: 'exploration' (both chosen by exploration weight), 'uniform'.
        let PAIRING_STRATEGY = 'hybrid';
        let pairingControlsHidden = false;
        const AVOID_RECENT = 100; // try to avoid pairs that occurred in last N battles

        // User management
        function switchUser(user) {
            currentUser = user;
            
            // Update UI
            document.querySelectorAll('.user-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + user).classList.add('active');
            document.getElementById('currentUserBadge').textContent = `Ingelogd als: ${user === 'luca' ? 'Luca' : 'Wouter'}`;
            
            // Load user-specific data
            if (user === 'luca') {
                coasters = coastersDataLuca.filter(c => c.operatief === 1);
            } else {
                coasters = coastersDataWouter.filter(c => c.operatief === 1);
            }
            
            // Load or initialize stats
            loadUserData();
            
            // Refresh displays
            displayBattle();
            updateRanking();
            // close menu after selection (if open)
            try { closeUserMenu(); } catch (e) {}
        }

        function loadUserData() {
            const statsKey = `coasterStats_${currentUser}`;
            const battlesKey = `totalBattles_${currentUser}`;
            const historyKey = `coasterHistory_${currentUser}`;

            coasterStats = JSON.parse(localStorage.getItem(statsKey)) || initializeStats();
            totalBattlesCount = parseInt(localStorage.getItem(battlesKey)) || 0;
            coasterHistory = JSON.parse(localStorage.getItem(historyKey)) || [];
            // load pairing settings for this user (if any)
            loadPairingSettings();
        }

        function initializeStats() {
            const stats = {};
            coasters.forEach(coaster => {
                stats[coaster.naam] = {
                    name: coaster.naam,
                    park: coaster.park,
                    manufacturer: coaster.fabrikant,
                    elo: 1500,
                    battles: 0,
                    wins: 0,
                    losses: 0
                };
            });
            return stats;
        }

        function saveData() {
            if (!currentUser) return;
            const statsKey = `coasterStats_${currentUser}`;
            const battlesKey = `totalBattles_${currentUser}`;
            const historyKey = `coasterHistory_${currentUser}`;

            localStorage.setItem(statsKey, JSON.stringify(coasterStats));
            localStorage.setItem(battlesKey, totalBattlesCount.toString());
            localStorage.setItem(historyKey, JSON.stringify(coasterHistory));
            // persist pairing settings per-user
            try {
                const settingsKey = `pairingSettings_${currentUser}`;
                const settings = { pairingStrategy: PAIRING_STRATEGY, eloProximityPower: ELO_PROXIMITY_POWER, pairingControlsHidden: pairingControlsHidden };
                localStorage.setItem(settingsKey, JSON.stringify(settings));
            } catch (e) {
                // ignore
            }
        }

        // Persist/load pairing settings per user
        function loadPairingSettings() {
            if (!currentUser) return;
            try {
                const settingsKey = `pairingSettings_${currentUser}`;
                const raw = localStorage.getItem(settingsKey);
                if (!raw) return applySettingsToUI();
                const s = JSON.parse(raw);
                if (s && typeof s.pairingStrategy === 'string') PAIRING_STRATEGY = s.pairingStrategy;
                if (s && typeof s.eloProximityPower === 'number') ELO_PROXIMITY_POWER = s.eloProximityPower;
                if (s && typeof s.pairingControlsHidden === 'boolean') pairingControlsHidden = s.pairingControlsHidden;
            } catch (e) {
                // ignore
            }
            applySettingsToUI();
        }

        function setPairingStrategy(val) {
            if (!val) return;
            PAIRING_STRATEGY = val;
            saveData();
            applySettingsToUI();
        }

        function setEloProximityPower(val) {
            const num = Number(val);
            if (isNaN(num)) return;
            ELO_PROXIMITY_POWER = num;
            const el = document.getElementById('eloProximityValue');
            if (el) el.textContent = num.toFixed(1);
            saveData();
        }

        function applySettingsToUI() {
            // update segmented toggle buttons
            const opts = document.querySelectorAll('.pair-option');
            opts.forEach(btn => {
                try {
                    const v = btn.getAttribute('data-value');
                    if (v === PAIRING_STRATEGY) btn.classList.add('active'); else btn.classList.remove('active');
                } catch (e) {}
            });
            // update range and label
            const range = document.getElementById('eloProximityRange');
            const val = document.getElementById('eloProximityValue');
            if (range) range.value = ELO_PROXIMITY_POWER;
            if (val) val.textContent = (Number(ELO_PROXIMITY_POWER) || 0).toFixed(1);
            // apply pairing controls hidden state
            const pairingDiv = document.getElementById('pairingControls');
            const toggleBtn = document.getElementById('pairingControlsToggle');
            if (pairingDiv) {
                if (pairingControlsHidden) pairingDiv.classList.add('collapsed'); else pairingDiv.classList.remove('collapsed');
            }
            if (toggleBtn) {
                if (pairingControlsHidden) {
                    toggleBtn.classList.add('collapsed');
                    toggleBtn.setAttribute('aria-expanded', 'false');
                    toggleBtn.title = 'Toon instellingen';
                } else {
                    toggleBtn.classList.remove('collapsed');
                    toggleBtn.setAttribute('aria-expanded', 'true');
                    toggleBtn.title = 'Verberg instellingen';
                }
            }
        }

        function togglePairingControls() {
            pairingControlsHidden = !pairingControlsHidden;
            applySettingsToUI();
            saveData();
        }

        // User menu (hamburger) toggle and outside-click handling
        function toggleUserMenu() {
            const menu = document.getElementById('userMenu');
            const btn = document.getElementById('userMenuToggle');
            if (!menu || !btn) return;
            const open = menu.classList.toggle('open');
            menu.setAttribute('aria-hidden', (!open).toString());
            btn.setAttribute('aria-expanded', open.toString());
            if (open) {
                // attach a one-time outside click listener
                setTimeout(() => {
                    document.addEventListener('click', outsideClickHandler);
                }, 0);
            } else {
                document.removeEventListener('click', outsideClickHandler);
            }
        }

        function closeUserMenu() {
            const menu = document.getElementById('userMenu');
            const btn = document.getElementById('userMenuToggle');
            if (!menu || !btn) return;
            menu.classList.remove('open');
            menu.setAttribute('aria-hidden', 'true');
            btn.setAttribute('aria-expanded', 'false');
            document.removeEventListener('click', outsideClickHandler);
        }

        function outsideClickHandler(ev) {
            const menu = document.getElementById('userMenu');
            const btn = document.getElementById('userMenuToggle');
            if (!menu || !btn) return;
            if (!menu.contains(ev.target) && ev.target !== btn) {
                closeUserMenu();
            }
        }

        // close on Escape
        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape') closeUserMenu();
        });

        // Floating help tooltip logic (delayed show, follows cursor)
        (function setupFloatingHelp(){
            const tooltip = document.createElement('div');
            tooltip.className = 'floating-help';
            document.body.appendChild(tooltip);

            let showTimer = null;
            let visible = false;

            function show(text, x, y) {
                tooltip.textContent = text;
                tooltip.style.left = x + 'px';
                tooltip.style.top = (y + 18) + 'px';
                tooltip.classList.add('show');
                visible = true;
            }

            function move(x, y) {
                tooltip.style.left = x + 'px';
                tooltip.style.top = (y + 18) + 'px';
            }

            function hide() {
                tooltip.classList.remove('show');
                visible = false;
                clearTimeout(showTimer);
                showTimer = null;
            }

            // attach handlers to pair-option buttons
            const buttons = document.querySelectorAll('.pair-option');
            buttons.forEach(btn => {
                let localTimer = null;
                const help = btn.getAttribute('data-help') || '';

                const onEnter = (ev) => {
                    // start delayed show (1s)
                    localTimer = setTimeout(() => {
                        show(help, ev.clientX, ev.clientY);
                    }, 1000);
                    btn._localTimer = localTimer;
                };

                const onMove = (ev) => {
                    if (visible) move(ev.clientX, ev.clientY);
                };

                const onLeave = () => {
                    if (btn._localTimer) { clearTimeout(btn._localTimer); btn._localTimer = null; }
                    hide();
                };

                btn.addEventListener('mouseenter', onEnter);
                btn.addEventListener('mousemove', onMove);
                btn.addEventListener('mouseleave', onLeave);

                // also hide on click
                btn.addEventListener('click', () => { if (btn._localTimer) { clearTimeout(btn._localTimer); btn._localTimer = null; } hide(); });
            });

            // hide tooltip on scroll or resize
            window.addEventListener('scroll', hide, { passive: true });
            window.addEventListener('resize', hide);
        })();

        // utility to make an unordered pair key (same for [A,B] and [B,A])
        function pairKey(nameA, nameB) {
            return [nameA, nameB].sort().join('|||');
        }

        // helper: record a battle into history
        function recordBattle(a, b, winnerName, loserName) {
            const entry = {
                pairKey: pairKey(a.naam, b.naam),
                left: a.naam,  // Store left position
                right: b.naam, // Store right position
                a: a.naam,
                b: b.naam,
                winner: winnerName,
                loser: loserName,
                timestamp: new Date().toISOString(),
                seed: (typeof seedNumber !== 'undefined') ? seedNumber : null
            };
            coasterHistory.push(entry);

            // keep history bounded if you want (optional)
            const MAX_HISTORY_KEEP = 10000;
            if (coasterHistory.length > MAX_HISTORY_KEEP) coasterHistory.splice(0, coasterHistory.length - MAX_HISTORY_KEEP);

            saveData();
        }

        // Attempt to pick a pair that hasn't occurred recently.
        // Strategy:
        //  - Use Math.random() (or seeded RNG if available) to sample pairs
        //  - Try up to `attempts` times to get a pair whose pairKey is not found in the last `avoid` entries.
        //  - If impossible, fall back to uniform random pair.
                function getPairAvoidingDuplicates({ attempts = 200, avoid = AVOID_RECENT } = {}) {
                    const length = coasters.length;
                    if (length < 2) return [];

                    const randomFn = (typeof rng === 'function') ? rng : Math.random;

                    // set of recent pairKeys to avoid
                    const recent = new Set();
                    const startIndex = Math.max(0, coasterHistory.length - avoid);
                    for (let i = startIndex; i < coasterHistory.length; i++) {
                        recent.add(coasterHistory[i].pairKey);
                    }

                    // build base weights that give higher probability to coasters with fewer battles
                    const weights = new Array(length);
                    for (let i = 0; i < length; i++) {
                        try {
                            const name = coasters[i].naam;
                            const stats = coasterStats && coasterStats[name] ? coasterStats[name] : null;
                            const battles = stats && typeof stats.battles === 'number' ? stats.battles : 0;
                            // base exploration weight: inverse of (1 + battles) ^ EXPLORATION_POWER
                            const w = 1 / Math.pow(1 + Math.max(0, battles), EXPLORATION_POWER);
                            weights[i] = w;
                        } catch (e) {
                            weights[i] = 1;
                        }
                    }

                    // helper: sample an index from a weight array
                    const sampleIndexFromWeights = (arr, rnd) => {
                        const tot = arr.reduce((s, v) => s + (isFinite(v) && v > 0 ? v : 0), 0);
                        if (!tot || !isFinite(tot) || tot <= 0) return Math.floor((rnd()) * length);
                        let r = rnd() * tot;
                        for (let k = 0; k < arr.length; k++) {
                            const val = isFinite(arr[k]) && arr[k] > 0 ? arr[k] : 0;
                            r -= val;
                            if (r <= 0) return k;
                        }
                        return arr.length - 1;
                    };

                    // strategy implementations
                    if (PAIRING_STRATEGY === 'uniform') {
                        // simple uniform sampling attempts avoiding recent
                        for (let t = 0; t < attempts; t++) {
                            const i = Math.floor(randomFn() * length);
                            let j = Math.floor(randomFn() * length);
                            if (length > 1) {
                                let guard = 0;
                                while (j === i && guard++ < 8) j = Math.floor(randomFn() * length);
                                if (j === i) j = (i + 1) % length;
                            }
                            const a = coasters[i], b = coasters[j];
                            const key = pairKey(a.naam, b.naam);
                            if (!recent.has(key)) return [a, b];
                        }
                    } else if (PAIRING_STRATEGY === 'exploration') {
                        // both selected from exploration-weighted distribution
                        const indexFromExploration = () => sampleIndexFromWeights(weights, randomFn);
                        for (let t = 0; t < attempts; t++) {
                            const i = indexFromExploration();
                            let j = indexFromExploration();
                            if (length > 1) {
                                let guard = 0;
                                while (j === i && guard++ < 8) j = indexFromExploration();
                                if (j === i) j = (i + 1) % length;
                            }
                            const a = coasters[i], b = coasters[j];
                            const key = pairKey(a.naam, b.naam);
                            if (!recent.has(key)) return [a, b];
                        }
                    }

                    // default/hybrid: pick one under-sampled coaster first, then a second biased by ELO-proximity
                    // (still favors under-sampled ones via base weights)
                    const indexFromExploration = () => sampleIndexFromWeights(weights, randomFn);
                    for (let t = 0; t < attempts; t++) {
                        const i = indexFromExploration();

                        const eloI = (coasterStats && coasterStats[coasters[i].naam] && typeof coasterStats[coasters[i].naam].elo === 'number') ? coasterStats[coasters[i].naam].elo : 1500;
                        const condWeights = new Array(length);
                        for (let k = 0; k < length; k++) {
                            if (k === i) { condWeights[k] = 0; continue; }
                            const nameK = coasters[k].naam;
                            const eloK = (coasterStats && coasterStats[nameK] && typeof coasterStats[nameK].elo === 'number') ? coasterStats[nameK].elo : 1500;
                            const diff = Math.abs(eloI - eloK) / ELO_DIFF_SCALE; // normalized diff
                            const proximityFactor = 1 / Math.pow(1 + diff, ELO_PROXIMITY_POWER);
                            const base = isFinite(weights[k]) && weights[k] > 0 ? weights[k] : 1;
                            condWeights[k] = base * proximityFactor;
                        }

                        let j = sampleIndexFromWeights(condWeights, randomFn);
                        if (j === i) {
                            let guard = 0;
                            while (j === i && guard++ < 8) j = sampleIndexFromWeights(condWeights, randomFn);
                            if (j === i) j = (i + 1) % length;
                        }

                        const a = coasters[i], b = coasters[j];
                        const key = pairKey(a.naam, b.naam);
                        if (!recent.has(key)) return [a, b];
                    }

                    // fallback scanning approach: try to find any unseen pair deterministically
                    const seenPairs = new Set(recent);
                    for (let i = 0; i < length; i++) {
                        for (let j = i + 1; j < length; j++) {
                            const a = coasters[i], b = coasters[j];
                            const key = pairKey(a.naam, b.naam);
                            if (!seenPairs.has(key)) {
                                if (randomFn() < 0.5) return [a, b]; else return [b, a];
                            }
                        }
                    }

                    // last resort: pick two via exploration+proximity weighting
                    const idx1 = indexFromExploration();
                    const elo1 = (coasterStats && coasterStats[coasters[idx1].naam] && typeof coasterStats[coasters[idx1].naam].elo === 'number') ? coasterStats[coasters[idx1].naam].elo : 1500;
                    const condWeightsFinal = new Array(length);
                    for (let k = 0; k < length; k++) {
                        if (k === idx1) { condWeightsFinal[k] = 0; continue; }
                        const eloK = (coasterStats && coasterStats[coasters[k].naam] && typeof coasterStats[coasters[k].naam].elo === 'number') ? coasterStats[coasters[k].naam].elo : 1500;
                        const diff = Math.abs(elo1 - eloK) / ELO_DIFF_SCALE;
                        const proximityFactor = 1 / Math.pow(1 + diff, ELO_PROXIMITY_POWER);
                        const base = isFinite(weights[k]) && weights[k] > 0 ? weights[k] : 1;
                        condWeightsFinal[k] = base * proximityFactor;
                    }
                    let idx2 = sampleIndexFromWeights(condWeightsFinal, randomFn);
                    if (idx2 === idx1) {
                        let guard = 0;
                        while (idx2 === idx1 && guard++ < 8) idx2 = sampleIndexFromWeights(condWeightsFinal, randomFn);
                        if (idx2 === idx1) idx2 = (idx1 + 1) % length;
                    }
                    return [coasters[idx1], coasters[idx2]];
                }

        // Replace getRandomCoasters() with duplicate-avoiding wrapper
        function getRandomCoasters() {
            return getPairAvoidingDuplicates();
        }

        function calculateElo(winnerElo, loserElo, K = 32) {
            const expectedWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
            const expectedLoser = 1 / (1 + Math.pow(10, (winnerElo - loserElo) / 400));
            
            const newWinnerElo = winnerElo + K * (1 - expectedWinner);
            const newLoserElo = loserElo + K * (0 - expectedLoser);
            
            return { newWinnerElo, newLoserElo };
        }

        function displayBattle() {
            if (!currentUser) {
                document.getElementById('battleContainer').innerHTML = '<div class="no-battles">Selecteer eerst een gebruiker hierboven! üëÜ</div>';
                return;
            }
            
            currentBattle = getRandomCoasters();
            const battleContainer = document.getElementById('battleContainer');
            
            // Get current rankings for both coasters
            const getRanking = (coasterName) => {
                const statsArray = Object.values(coasterStats);
                const sorted = [...statsArray].sort((a, b) => b.elo - a.elo);
                const rank = sorted.findIndex(c => c.name === coasterName) + 1;
                return rank;
            };
            
            const rank1 = getRanking(currentBattle[0].naam);
            const rank2 = getRanking(currentBattle[1].naam);
            
            battleContainer.innerHTML = `
                <div class="coaster-card left-card" onclick="chooseWinner(0)">
                    <div class="coaster-name">${currentBattle[0].naam}</div>
                    <div class="coaster-info">
                        <div class="coaster-info-row">
                            <span class="info-label">üìä Ranking:</span>
                            <span class="info-value">#${rank1}</span>
                        </div>
                        <div class="coaster-info-row">
                            <span class="info-label">üé¢ Park:</span>
                            <span class="info-value">${currentBattle[0].park}</span>
                        </div>
                        <div class="coaster-info-row">
                            <span class="info-label">üè≠ Fabrikant:</span>
                            <span class="info-value">${currentBattle[0].fabrikant}</span>
                        </div>
                    </div>
                </div>
                
                <div class="coaster-card right-card" onclick="chooseWinner(1)">
                    <div class="coaster-name">${currentBattle[1].naam}</div>
                    <div class="coaster-info">
                        <div class="coaster-info-row">
                            <span class="info-label">üìä Ranking:</span>
                            <span class="info-value">#${rank2}</span>
                        </div>
                        <div class="coaster-info-row">
                            <span class="info-label">üé¢ Park:</span>
                            <span class="info-value">${currentBattle[1].park}</span>
                        </div>
                        <div class="coaster-info-row">
                            <span class="info-label">üè≠ Fabrikant:</span>
                            <span class="info-value">${currentBattle[1].fabrikant}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function chooseWinner(index) {
            if (!currentUser) return;
            if (isProcessingChoice) return; // Prevent double-clicking
            
            isProcessingChoice = true; // Lock to prevent multiple submissions
            
            const winner = currentBattle[index];
            const loser = currentBattle[1 - index];
            
            // Get ranking BEFORE the battle
            const getRanking = (coasterName) => {
                const statsArray = Object.values(coasterStats);
                const sorted = [...statsArray].sort((a, b) => b.elo - a.elo);
                const rank = sorted.findIndex(c => c.name === coasterName) + 1;
                return rank;
            };
            
            const oldRank = getRanking(winner.naam);
            
            // Get current ELO ratings
            const winnerStats = coasterStats[winner.naam];
            const loserStats = coasterStats[loser.naam];
            
            // Calculate new ELO ratings
            const { newWinnerElo, newLoserElo } = calculateElo(winnerStats.elo, loserStats.elo);
            
            // Update stats
            winnerStats.elo = newWinnerElo;
            winnerStats.battles++;
            winnerStats.wins++;
            
            loserStats.elo = newLoserElo;
            loserStats.battles++;
            loserStats.losses++;
            
            totalBattlesCount++;
            
            // Get ranking AFTER the battle
            const newRank = getRanking(winner.naam);
            const rankChange = oldRank - newRank; // positive = climbed
            
            // record to history before saving (pass in battle order: left=index 0, right=index 1)
            recordBattle(currentBattle[0], currentBattle[1], winner.naam, loser.naam);

            // Save to localStorage (now also saves history)
            saveData();
            
            // Visual feedback
            const cards = document.querySelectorAll('.coaster-card');
            cards[index].classList.add('winner');
            cards[1 - index].classList.add('loser');
            
            // Show rank climb animation if winner climbed in ranking
            if (rankChange > 0) {
                const badge = document.createElement('div');
                badge.className = 'rank-change-badge';
                badge.innerHTML = `
                    <span class="arrow">‚Üë</span>
                    <span>+${rankChange}</span>
                `;
                cards[index].style.position = 'relative';
                cards[index].appendChild(badge);
                
                // Remove badge after animation completes
                setTimeout(() => {
                    if (badge.parentElement) {
                        badge.remove();
                    }
                }, 4000);
            }
            
            // Load next battle after longer delay to show animations
            setTimeout(() => {
                displayBattle();
                isProcessingChoice = false; // Unlock for next battle
            }, 1500);
        }

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (!currentUser) return;
            
            const battleTab = document.getElementById('battle-tab');
            if (!battleTab.classList.contains('active')) return;
            
            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                chooseWinner(0);
            } else if (event.key === 'ArrowRight') {
                event.preventDefault();
                chooseWinner(1);
            }
        });

        // Close keyboard hint and persist preference
        function closeKeyboardHint() {
            const hint = document.getElementById('keyboardHint');
            if (hint) {
                hint.classList.add('hidden');
                localStorage.setItem('keyboardHintDismissed', 'true');
            }
        }

        // Check if hint was previously dismissed
        window.addEventListener('DOMContentLoaded', () => {
            const dismissed = localStorage.getItem('keyboardHintDismissed');
            if (dismissed === 'true') {
                const hint = document.getElementById('keyboardHint');
                if (hint) hint.classList.add('hidden');
            }
        });

        // Global undo for history deletes: Cmd+Z / Ctrl+Z (but not when typing in an input)
        function undoLastDelete() {
            if (!deletedHistoryStack || deletedHistoryStack.length === 0) return false;
            const item = deletedHistoryStack.pop();
            if (!item || !item.entry) return false;

            // Re-insert at original index where possible, otherwise append
            const insertIndex = (typeof item.index === 'number' && item.index >= 0 && item.index <= coasterHistory.length) ? item.index : coasterHistory.length;
            coasterHistory.splice(insertIndex, 0, item.entry);
            saveData();
            displayHistory();
            // Show a small toast confirming undo (include restored pair)
            try {
                const a = item.entry && item.entry.a ? item.entry.a : '';
                const b = item.entry && item.entry.b ? item.entry.b : '';
                showToast(`Hersteld: ${a} ‚Üî ${b}`);
            } catch (e) {
                showToast('Hersteld: matchup teruggezet');
            }
            return true;
        }

        document.addEventListener('keydown', (ev) => {
            // Ignore undo while focused on text inputs or contenteditable areas
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

            const isUndo = (ev.key && ev.key.toLowerCase() === 'z') && (ev.metaKey || ev.ctrlKey);
            if (!isUndo) return;

            // Only act when there's a history tab or current user
            if (!currentUser) return;

            const handled = undoLastDelete();
            if (handled) {
                ev.preventDefault();
            }
        });

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            try { event.target.classList.add('active'); } catch (e) {}
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
            
            if (tabName === 'ranking') {
                updateRanking();
            } else if (tabName === 'history') {
                displayHistory();
            }
        }

        // Render the history in the history tab
        function displayHistory() {
            const container = document.getElementById('historyContainer');
            if (!container) return;
            if (!coasterHistory || coasterHistory.length === 0) {
                container.innerHTML = '<div class="no-battles">Nog geen battles ‚Äî start met kiezen om history op te bouwen.</div>';
                return;
            }

            const query = document.getElementById('historySearch') ? document.getElementById('historySearch').value.trim().toLowerCase() : '';

            // Render only pair, highlight winner with a green pill and add a subtle delete button
            const rows = coasterHistory.slice().reverse().map((entry, idx) => {
                const originalIndex = coasterHistory.length - 1 - idx;
                // Use stored left/right positions if available, otherwise fall back to a/b
                let a = entry.left || entry.a;
                let b = entry.right || entry.b;
                const winner = entry.winner;

                const pairText = `${a} ‚Üî ${b}`;
                if (query && !pairText.toLowerCase().includes(query) && !a.toLowerCase().includes(query) && !b.toLowerCase().includes(query)) {
                    return '';
                }

                // If there's a search query, put the matching coaster on the left
                if (query) {
                    const aMatches = a.toLowerCase().includes(query);
                    const bMatches = b.toLowerCase().includes(query);
                    
                    // If only b matches, swap them
                    if (!aMatches && bMatches) {
                        [a, b] = [b, a];
                    }
                }

                const aHtml = (winner === a) ? `<span class="clickable-history-name" onclick="viewCoasterHistory('${a.replace(/'/g, "\\'")}')" style="cursor:pointer;"><span class="winner-pill">${escapeHtml(a)}</span></span>` : `<span class="clickable-history-name" onclick="viewCoasterHistory('${a.replace(/'/g, "\\'")}')" style="cursor:pointer;">${escapeHtml(a)}</span>`;
                const bHtml = (winner === b) ? `<span class="clickable-history-name" onclick="viewCoasterHistory('${b.replace(/'/g, "\\'")}')" style="cursor:pointer;"><span class="winner-pill">${escapeHtml(b)}</span></span>` : `<span class="clickable-history-name" onclick="viewCoasterHistory('${b.replace(/'/g, "\\'")}')" style="cursor:pointer;">${escapeHtml(b)}</span>`;

                return `
                    <div class="history-row">
                        <div class="history-pair"><strong>${aHtml}</strong><span>‚Üî</span><strong>${bHtml}</strong></div>
                        <div style="flex:0 0 auto;">
                            <button class="history-switch" title="Wissel winnaar" onclick="switchHistoryWinner(${originalIndex})">‚áÑ</button>
                            <button class="history-delete" title="Verwijder deze matchup" onclick="deleteHistoryEntry(${originalIndex})">‚úñ</button>
                        </div>
                    </div>
                `;
            }).join('');

            // If filtering removed all rows, show empty state
            if (!rows || rows.trim() === '') {
                container.innerHTML = '<div class="no-battles">Geen matchups gevonden voor deze zoekopdracht.</div>';
            } else {
                container.innerHTML = rows;
            }
        }

        let selectedAutocompleteIndex = -1;

        function getHistoryAutocompleteSuggestions() {
            const coasterNames = new Set();
            Object.keys(coasterStats).forEach(name => coasterNames.add(name));
            return Array.from(coasterNames).sort();
        }

        function handleHistorySearchInput() {
            const input = document.getElementById('historySearch');
            const clearBtn = document.getElementById('clearHistorySearchBtn');
            clearBtn.style.display = input.value.trim() ? 'block' : 'none';
            showHistoryAutocomplete();
        }

        function clearHistorySearch() {
            const input = document.getElementById('historySearch');
            const clearBtn = document.getElementById('clearHistorySearchBtn');
            input.value = '';
            clearBtn.style.display = 'none';
            const dropdown = document.getElementById('historyAutocomplete');
            dropdown.classList.remove('show');
            displayHistory();
        }

        function showHistoryAutocomplete() {
            const input = document.getElementById('historySearch');
            const dropdown = document.getElementById('historyAutocomplete');
            const query = input.value.trim().toLowerCase();
            
            const allSuggestions = getHistoryAutocompleteSuggestions();
            const filteredSuggestions = query === '' 
                ? allSuggestions 
                : allSuggestions.filter(name => name.toLowerCase().includes(query));
            
            if (filteredSuggestions.length === 0) {
                dropdown.classList.remove('show');
                return;
            }
            
            dropdown.innerHTML = filteredSuggestions.map((name, idx) => 
                `<div class="autocomplete-item" data-index="${idx}" onclick="selectHistorySuggestion('${name.replace(/'/g, "\\'")}')">${escapeHtml(name)}</div>`
            ).join('');
            
            dropdown.classList.add('show');
            selectedAutocompleteIndex = -1;
        }

        function selectHistorySuggestion(name) {
            const input = document.getElementById('historySearch');
            const clearBtn = document.getElementById('clearHistorySearchBtn');
            input.value = name;
            clearBtn.style.display = 'block';
            document.getElementById('historyAutocomplete').classList.remove('show');
            displayHistory();
        }

        function handleHistorySearchKeydown(event) {
            const dropdown = document.getElementById('historyAutocomplete');
            const items = dropdown.querySelectorAll('.autocomplete-item');
            
            if (!dropdown.classList.contains('show') || items.length === 0) return;
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'Enter') {
                event.preventDefault();
                if (selectedAutocompleteIndex >= 0 && selectedAutocompleteIndex < items.length) {
                    items[selectedAutocompleteIndex].click();
                }
            } else if (event.key === 'Escape') {
                dropdown.classList.remove('show');
            }
        }

        function updateAutocompleteSelection(items) {
            items.forEach((item, idx) => {
                if (idx === selectedAutocompleteIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
            const dropdown = document.getElementById('historyAutocomplete');
            const input = document.getElementById('historySearch');
            if (dropdown && input && !input.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // delete a single history entry by its index in coasterHistory
        function deleteHistoryEntry(index) {
            if (typeof index !== 'number' || index < 0 || index >= coasterHistory.length) return;

            const removed = coasterHistory.splice(index, 1)[0];

            // push onto undo stack
            try {
                deletedHistoryStack.push({ entry: removed, index });
                if (deletedHistoryStack.length > MAX_UNDO_STACK) deletedHistoryStack.shift();
            } catch (e) {
                // fallback: if something goes wrong with stack, ignore
            }

            saveData();
            displayHistory();
            // show toast confirming deletion
            try {
                showToast(`Verwijderd: ${removed.a} ‚Üî ${removed.b}`);
            } catch (e) {}
        }

        // switch the winner in a history entry
        function switchHistoryWinner(index) {
            if (typeof index !== 'number' || index < 0 || index >= coasterHistory.length) return;

            const entry = coasterHistory[index];
            const oldWinner = entry.winner;
            const newWinner = (entry.winner === entry.a) ? entry.b : entry.a;
            const oldLoser = (entry.winner === entry.a) ? entry.b : entry.a;
            
            // Update the winner in the history entry
            entry.winner = newWinner;
            
            // Update ELO ratings by reversing the previous outcome
            // First, reverse the old result
            const winnerStats = coasterStats[oldWinner];
            const loserStats = coasterStats[oldLoser];
            
            if (winnerStats && loserStats) {
                // Reverse old outcome
                winnerStats.wins--;
                loserStats.losses--;
                
                // Apply new outcome
                loserStats.wins++;
                winnerStats.losses++;
                
                // Recalculate ELO (swap who won)
                const { newWinnerElo, newLoserElo } = calculateElo(loserStats.elo, winnerStats.elo);
                loserStats.elo = newWinnerElo;
                winnerStats.elo = newLoserElo;
            }
            
            saveData();
            displayHistory();
            updateRanking();
            
            showToast(`Winnaar gewisseld: ${newWinner} wint nu van ${oldLoser}`);
        }

        // small helper to escape HTML in names
        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, function (s) {
                return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s];
            });
        }

        // Toast helper: show a small non-blocking message at bottom-center
        function showToast(message, duration = 2400) {
            try {
                const existing = document.querySelector('.toast');
                if (existing) {
                    existing.remove();
                }
                const t = document.createElement('div');
                t.className = 'toast';
                t.textContent = message;
                document.body.appendChild(t);
                // Force layout then add class to trigger transition
                void t.offsetWidth;
                t.classList.add('show');
                setTimeout(() => {
                    t.classList.remove('show');
                    setTimeout(() => t.remove(), 300);
                }, duration);
            } catch (e) {
                // ignore failures silently
            }
        }

        // clear history for user
        function clearHistory() {
            if (!currentUser) return;
            coasterHistory = [];
            saveData();
            displayHistory();
        }

        // export history JSON
        function exportHistory() {
            if (!coasterHistory || coasterHistory.length === 0) {
                alert('Geen history om te exporteren.');
                return;
            }
            const blob = new Blob([JSON.stringify(coasterHistory, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `coaster_history_${currentUser || 'anonymous'}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function sortRanking(column) {
            if (currentSort.column === column) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = column;
                currentSort.ascending = false;
            }
            updateRanking();
        }

        function updateRanking() {
            if (!currentUser) {
                document.getElementById('rankingBody').innerHTML = '<tr><td colspan="9" class="no-battles">Selecteer eerst een gebruiker! üé¢</td></tr>';
                return;
            }
            
            const statsArray = Object.values(coasterStats);
            const totalCoasters = statsArray.length;
            const totalBattles = totalBattlesCount;
            const avgBattles = totalBattles > 0 ? (totalBattles * 2 / totalCoasters).toFixed(1) : 0;
            
            document.getElementById('totalBattles').textContent = totalBattles;
            document.getElementById('totalCoasters').textContent = totalCoasters;
            document.getElementById('avgBattlesPerCoaster').textContent = avgBattles;
            
            const sorted = [...statsArray].sort((a, b) => {
                let aVal, bVal;
                
                switch(currentSort.column) {
                    case 'name':
                        aVal = a.name;
                        bVal = b.name;
                        break;
                    case 'park':
                        aVal = a.park;
                        bVal = b.park;
                        break;
                    case 'manufacturer':
                        aVal = a.manufacturer;
                        bVal = b.manufacturer;
                        break;
                    case 'elo':
                        aVal = a.elo;
                        bVal = b.elo;
                        break;
                    case 'battles':
                        aVal = a.battles;
                        bVal = b.battles;
                        break;
                    case 'wins':
                        aVal = a.wins;
                        bVal = b.wins;
                        break;
                    case 'losses':
                        aVal = a.losses;
                        bVal = b.losses;
                        break;
                    case 'winrate':
                        aVal = a.battles > 0 ? (a.wins / a.battles) : 0;
                        bVal = b.battles > 0 ? (b.wins / b.battles) : 0;
                        break;
                    default:
                        aVal = a.elo;
                        bVal = b.elo;
                }
                
                if (typeof aVal === 'string') {
                    return currentSort.ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    return currentSort.ascending ? aVal - bVal : bVal - aVal;
                }
            });
            
            document.querySelectorAll('.ranking-table th').forEach(th => {
                const text = th.textContent.replace(' ‚¨ÜÔ∏è', '').replace(' ‚¨áÔ∏è', '');
                th.textContent = text;
            });
            
            const activeHeader = Array.from(document.querySelectorAll('.ranking-table th'))
                .find(th => th.textContent.toLowerCase().includes(currentSort.column) || 
                            (currentSort.column === 'elo' && th.textContent.includes('ELO')));
            
            if (activeHeader) {
                const text = activeHeader.textContent.replace(' ‚¨ÜÔ∏è', '').replace(' ‚¨áÔ∏è', '');
                activeHeader.textContent = text + (currentSort.ascending ? ' ‚¨ÜÔ∏è' : ' ‚¨áÔ∏è');
            }
            
            const tbody = document.getElementById('rankingBody');
            // Mobile card container
            let rankingCardsContainer = document.getElementById('rankingCards');
            if (!rankingCardsContainer) {
                const container = document.createElement('div');
                container.id = 'rankingCards';
                container.className = 'ranking-cards';
                const table = document.querySelector('.ranking-table');
                table.parentNode.insertBefore(container, table.nextSibling);
                rankingCardsContainer = container;
            }


            
            if (totalBattles === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="no-battles">Start met battlen om je ranking te zien! üé¢</td></tr>';
                rankingCardsContainer.innerHTML = '';
                return;
            }

            // Build table rows and mobile cards
            const rowsHtml = [];
            const cardsHtml = [];

            sorted.forEach((coaster, index) => {
                const rank = index + 1;
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '';
                const winrate = coaster.battles > 0 ? ((coaster.wins / coaster.battles) * 100).toFixed(1) : '0.0';
                const escapedName = coaster.name.replace(/'/g, "\\'");

                rowsHtml.push(`
                    <tr>
                        <td><span class="rank-medal">${medal}</span>${rank}</td>
                        <td><strong>${coaster.name}</strong></td>
                        <td>${coaster.park}</td>
                        <td>${coaster.manufacturer}</td>
                        <td><span class="elo-score">${Math.round(coaster.elo)}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.battles}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.wins}</span></td>
                        <td><span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">${coaster.losses}</span></td>
                        <td>${winrate}%</td>
                    </tr>
                `);

                // Card for mobile
                cardsHtml.push(`
                    <div class="ranking-card" data-rank="${rank}">
                        <div class="ranking-left">
                            <div class="rank">${rank}</div>
                            <div class="name">${coaster.name}</div>
                            <div class="meta">${coaster.park} ‚Ä¢ ${coaster.manufacturer}</div>
                        </div>
                        <div class="ranking-right">
                            <div class="elo">${Math.round(coaster.elo)}</div>
                            <div class="stats">
                                <span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">W: ${coaster.wins}</span>
                                <span class="clickable-stat" onclick="viewCoasterHistory('${escapedName}')" title="View battle history">L: ${coaster.losses}</span>
                            </div>
                        </div>
                    </div>
                `);
            });

            tbody.innerHTML = rowsHtml.join('');
            rankingCardsContainer.innerHTML = cardsHtml.join('');
        }

        function filterRanking() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const rows = document.querySelectorAll('#rankingBody tr');
            
            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        }

        function viewCoasterHistory(coasterName) {
            // Switch to history tab
            switchTab('history');
            
            // Set the search box value to the coaster name
            const historySearch = document.getElementById('historySearch');
            const clearBtn = document.getElementById('clearHistorySearchBtn');
            historySearch.value = coasterName;
            clearBtn.style.display = 'block';
            
            // Trigger the search/filter
            displayHistory();
        }

        function resetRankings() {
            if (!currentUser) return;
            
            if (confirm(`Weet je zeker dat je alle data voor ${currentUser === 'luca' ? 'Luca' : 'Wouter'} wilt resetten? Dit kan niet ongedaan worden gemaakt!`)) {
                if (confirm('Laatste waarschuwing! Alle battles en rankings worden gewist. Doorgaan?')) {
                    coasterStats = initializeStats();
                    totalBattlesCount = 0;
                    saveData();
                    displayBattle();
                    updateRanking();
                    alert('Alle data is gereset! üîÑ');
                }
            }
        }

        // Initialize - check if there's a saved user preference
        const savedUser = localStorage.getItem('lastUser');
        if (savedUser && (savedUser === 'luca' || savedUser === 'wouter')) {
            switchUser(savedUser);
        }

        // Save user preference when switching
        const originalSwitchUser = switchUser;
        switchUser = function(user) {
            originalSwitchUser(user);
            localStorage.setItem('lastUser', user);
        };
    </script>

</body></html>
